##设计模式##

一、创建型设计模式

1. 抽象工厂（Abstract Factory)

    &&：工厂设计模式的要点在于，按接口编程之：creator接口 + product接口；
    1）在creator接口中定义工厂产生产品的规则，工厂是一个，根据不同的产品原型生产不同的产品；
    2）在product接口中规定各种产品的定义规则，各种各样的产品按照统一的规则定义不同的产品（实际上也就是利用了接口的多态）

2. 生成器（Builder）

3. 工厂方法（Factory Method)

4. 原型（Prototype）

    &&:原型模式的要点在于，按接口编程之：
        Iprototype(规范原型类的格式) =>实现接口创建原型=>克隆原型生成被调用子类=>client调用子类

    ⚠️：克隆原型时，并不等于实例化原型类，只是复制了原型的属性和方法，像构造函数是在类实例化的过程中才被调用的方法是
       不会被执行的，千万不要将影响类属性的操作放到构造函数中，习惯上就是构造函数不做具体操作。
    ¥：一个类的构造函数如果放置了太多操作，就会不灵活，约束的条件会变多，会导致过度耦合。

    ⏰：印象笔记中有关此模式的详细介绍。

5. 单例（Singleton)

二、结构型设计模式

6. 适配器模式（Adapter）（类和对象）

    1）类适配器

        由于适配器充当的角色为衔接两个类的适配，因此适配器需要继承两个类的功能，所以类适配器需要重写的代码很少。当然，
      由于给定了一个将要由适配器（Adapter）继承的被继承者（Adaptee），这种绑定很紧密，所以使用类适配器模式创建应用
      时，必须要非常清楚将要在哪里发生适配。

        由于PHP不支持双重继承（Java也不支持）所以一般会采用如下技巧：（也即利用类继承结合接口实现）,以实现双重继承。
            ⚠️：class ChildClass extends ParentClass implements ISomeInterface

        所以，实现类适配器模式时，参与者必须包含一个PHP接口。

    2）对象适配器



7. 桥接模式（Bridge）

8. 组合模式（Composite)

9. 装饰器模式（Decorator)

10. 外观模式（Pacade)

11. 享元模式（Flyweight)

12. 代理模式（Proxy)
