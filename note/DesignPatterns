##设计模式##

一、创建型设计模式

1. 抽象工厂（Abstract Factory)

    &&：工厂设计模式的要点在于，按接口编程之：creator接口 + product接口；
    1）在creator接口中定义工厂产生产品的规则，工厂是一个，根据不同的产品原型生产不同的产品；
    2）在product接口中规定各种产品的定义规则，各种各样的产品按照统一的规则定义不同的产品（实际上也就是利用了接口的多态）

2. 生成器（Builder）

3. 工厂方法（Factory Method)

4. 原型（Prototype）

    &&:原型模式的要点在于，按接口编程之：
        Iprototype(规范原型类的格式) =>实现接口创建原型=>克隆原型生成被调用子类=>client调用子类

    ⚠️：克隆原型时，并不等于实例化原型类，只是复制了原型的属性和方法，像构造函数是在类实例化的过程中才被调用的方法是
       不会被执行的，千万不要将影响类属性的操作放到构造函数中，习惯上就是构造函数不做具体操作。
    ¥：一个类的构造函数如果放置了太多操作，就会不灵活，约束的条件会变多，会导致过度耦合。

    ⏰：印象笔记中有关此模式的详细介绍。

5. 单例（Singleton)

二、结构型设计模式

6. 适配器模式（Adapter）（类和对象）

    1）类适配器

        ⏰ ：在设计模式中，通常谈及继承时，都是具体类继承抽象类，很少有像适配器这样，一个具体类继承另一个具体类。

        由于适配器充当的角色为衔接两个类的适配，因此适配器需要继承两个类的功能，所以类适配器需要重写的代码很少。当然，
      由于给定了一个将要由适配器（Adapter）继承的被继承者（Adaptee），这种绑定很紧密，所以使用类适配器模式创建应用
      时，必须要非常清楚将要在哪里发生适配。

        由于PHP不支持双重继承（Java也不支持）所以一般会采用如下技巧：（也即利用类继承结合接口实现）,以实现双重继承。
            ⚠️：class ChildClass extends ParentClass implements ISomeInterface

        所以，实现类适配器模式时，参与者必须包含一个PHP接口。

        （此部分需要上网看别人资料，深入思考）

    2）对象适配器

        &&：对象适配器使用的是组合，而不是类适配器的继承。
         1.采用类适配器模式时，适配器可以继承适配者的绝大多数功能，只需要，通过接口的微调实现适配器的灵活对接。
         2.在对象适配器模式中，适配器使用被适配者。



7. 桥接模式（Bridge）

8. 组合模式（Composite)

9. 装饰器模式（Decorator)

10. 外观模式（Pacade)

11. 享元模式（Flyweight)

12. 代理模式（Proxy)


三、结构型设计模式

13. 适配器模式（Adapter) (类和对象）

14. 桥接模式（Bridge)

15. 组合模式（Composite）

16. 装饰器模式（Decorator)

17. 外观模式（Pacade)

18. 享元模式（Flyweight)

19. 代理模式（Proxy)

四、行为型设计模式

20. 职责链模式（Chain of Responsibility)

21. 命令模式（Command)

22. 解释器模式（Interpreter) (类设计模式）

23. 迭代器模式（Interator)

24. 中介者模式（Mediator)

25. 备忘录模式（Memento）

26. 观察者模式（Observer)

27. 状态模式（Strategy)

28. 策略模式（Strategy）

29. 模版方法模式（Template Method) (类设计模式）

30. 访问者模式（Visitor)
